from abc import ABC, abstractmethod
import numpy as np
from time import time
from os.path import expanduser


class StackLattice(ABC):
    """abstract base class for wire lattices made of stacked planes"""
    N_LIMIT = 1_000_000

    def __init__(self):
        super().__init__()
        self._planes = []  # list of PointPlane objects to be stacked
        self._N = None  # number of lattice points
        self._nz = None  # number of planes in wire lattice
        self._dz = None  # spacing between planes in a0=1 units
        self._dxy = None  # xy-plane offset between planes in a0=1 units
        self._D = None  # approximate diameter in a0=1 units
        self._L = None  # length in in a0=1 units
        self._basis = {1: [np.zeros(3)]}  # atom types attached to lattice
        self._area = None

    @abstractmethod
    def get_points(self, t):
        """return an array of all atom points of type `t`"""
        raise NotImplementedError

    @abstractmethod
    def write_map(self, file_path):
        """write phana compatible map file for smallest unit cell"""
        raise NotImplementedError

    @property
    @abstractmethod
    def D(self):
        # implement diameter formula for each subclass
        raise NotImplementedError

    @property
    @abstractmethod
    def area(self):
        return NotImplementedError

    # --------------------------------------------------------------------------
    # concrete properties
    # --------------------------------------------------------------------------

    @property
    def planes(self):
        return self._planes

    @property
    def N(self):
        if self._N is None:
            N = 0
            for plane in self.planes:
                N += plane.N
            self._N = N
        return self._N

    @property
    def nz(self):
        if self._nz is None:
            self._nz = len(self.planes)
        return self._nz

    @property
    def L(self):
        return self.L

    @L.getter
    def L(self):
        if self._L is None:
            self._L = self.dz * (self.nz - 1)
        return self._L

    @property
    def basis(self):
        return self._basis

    @property
    def dz(self):
        return self._dz

    @property
    def dxy(self):
        return self._dxy

    # --------------------------------------------------------------------------
    # concrete methods
    # --------------------------------------------------------------------------

    def add_basis(self, t, pt):
        """add an atom of type `t` at point `pt`"""
        pt = np.asarray(pt)
        if len(pt) != 3:
            raise ValueError("basis point must be 3-dimensional")

        if t in self._basis:
            self._basis[t].append(pt)
        else:
            self._basis[t] = [pt]

    def write_points(self, file_path, scale=1.0):
        """write LAMMPS/OVITO compatible data file of all atom points"""
        N_atoms = 0.  # total number of atoms
        points_dict = {}
        for b in self.basis:
            points_dict[b] = scale * self.get_points(b)
            N_atoms += self.N * len(self.basis[b])

        t1 = time()
        path_ = expanduser(file_path)
        with open(path_, "w") as file_:
            # header (ignored)
            file_.write("TSL atom coordinates generated by `twinstack.py`\n")
            file_.write("\n")

            # number of atoms and number of atom types
            file_.write("%d atoms\n" % N_atoms)
            file_.write("%d atom types\n" % len(self.basis))
            file_.write("\n")

            # simulation box
            x = 2 * scale * self.D  # keep atoms' (x,y) in box
            y = x
            z = self.L
            file_.write("{} {} xlo xhi\n".format(-x / 2., x / 2.))
            file_.write("{} {} ylo yhi\n".format(-y / 2., y / 2.))
            file_.write("{} {} zlo zhi\n".format(0., z))
            file_.write("\n")

            # Atoms section
            file_.write("Atoms # atomic\n")
            file_.write("\n")
            id_ = 1
            for typ, points in points_dict.items():
                for pt in points:
                    file_.write("{} {} {} {} {} 0 0 0\n"
                                .format(id_, typ, pt[0], pt[1], pt[2] % z))
                    id_ += 1
            t2 = time()
            print("wrote %d atoms to data file '%s' in %f seconds"
                  % (N_atoms, path_, t2 - t1))


class PointPlane(ABC):

    ehex_vectors = np.array([[1., 0., 0.], [-.5, np.sqrt(3) / 2., 0.]])
    ehex_delta = .25 * np.array([1, -1. / np.sqrt(3), 0.])
    ohex_vectors = np.array([[1., 0., 0.], [-.5, np.sqrt(3) / 2., 0.]])
    ohex_delta = np.array([[1., 0., 0.], [-.5, np.sqrt(3) / 2., 0.]])
    sq_vectors = np.array([[1., 0., 0.], [0., 1., 0.]])

    def __init__(self, scale):
        super().__init__()
        self._N = None
        self._D = None
        self._nz = None
        self._vectors = None
        self._area = None
        self._com = None
        self._scale = scale

    @abstractmethod
    def get_points(self, center=True):
        """return an array of all atom points in 3-space"""
        raise NotImplementedError

    @property
    @abstractmethod
    def N(self):
        return self._N

    @property
    @abstractmethod
    def D(self):
        # implement diameter formula for each subclass
        raise NotImplementedError

    @property
    @abstractmethod
    def area(self):
        # implement area formula for each subclass
        raise NotImplementedError

    @property
    @abstractmethod
    def vectors(self):
        raise NotImplementedError

    @property
    @abstractmethod
    def com(self):
        # implement com formula for each subclass
        raise NotImplementedError

    @property
    def scale(self):
        # global scaling of all point in plane
        return self._scale
